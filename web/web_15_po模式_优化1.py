#!/usr/bin/python3
# -*- coding: utf-8 -*-

'''
web-第4周-第1节课
深入分层应用
对应练习：web_po_v2这个包
优化1：
对于页面对象，将页面元素提取出来放到另外一个包下，还是以页面区分。
那页面对象类中就只放页面操作函数。然后导入页面元素的类就可以了。
分层：Pagelocators，与PageObjects结构是对应的。

补充小技巧：
# 问题：在页面对象类调用driver的方法时，因为driver是外部传入的，这里写代码时无法自动弹起driver相关方法
# 解决-小技巧：
# （1）导入from selenium.webdriver.remote.webdriver import WebDriver
# （2）    def __init__(self, driver: WebDriver):
#         self.driver = driver

优化2：
测试数据单独管理：
1、数据共用、模块级共用、全局级共用。
2、测试环境、预发布环境、生产环境。---不同环境的数据应该分开管理。
基于以上原因，结论：所有数据全部拿出来统一管理。
分层：test_dates，与TestCases模块结构是对应的。可以区分为模块数据和全局数据。

目前优化后有四层：PageLocators, PageObjects, test_cases, test_dates
'''

'''
web-第4周-第2节课 
对应web_po_v3，但是与web_po_v2写在一起了
复杂用例的设计和实现
以投资用例来讲解，对应：invest.py文件以及test_invest.py
关于自动化测试用例原则，在invest.py中
自己总结-这节课的学习收获：写用例之前先分析，先把手工用例写出来（用例名称、前置、步骤、断言），筛选可以自动化的用例，然后再写。
在写的过程中，先把架子搭起来，然后再具体化。
搭架子步骤：
（1）testCases-class/setUP/tearDown/用例（细节先用pass代替） 
（2）理清用例的步骤和断言，明了需要哪些页面-哪些操作
（3）pageObects-补充页面需要的操作（细节先用pass代替） 
（4）PageLocatir-补充页面需要的元素
（5）补充细节，调试用例

重要：（从invest.py文件中拿过来的）
自动化用例原则
自动化用例设计和筛选原则：
1.不是所有手工用例都要转化为自动化测试用例
2.考虑大脚本开发成功，不要选择流程太复杂的用例。如果有必要，可以把流程拆分为多个用例来实现脚本。
3.选择的用例最好可以构建成场景。例如，一个功能模块，分多个用例，多个用例使用同一个场景。
4.选择的用例可以带有目的性。例如，这部分用例是做冒烟测试，那部分用例是回归测试等。当然会存在重叠的关系。
如果当前用例不能满足需求，那么唯有修改用例来适应脚本和需求。
5.选取的用例可以是你认为重复执行、很烦琐的部分。如字段验证、提示信息验证，这部分很适合自动化测试。
6.选取的用例可以是主体流程，这部分适用于冒烟测试。
7.自动化测试也可以用来做配置检查、数据库检查。这些可能超越了手工用例，但也算是用例拓展的一部分，项目负责人可以有选择的增加。
8.平时在手工测试时，如果需要构造一些复杂的数据或重复一些简单的机械式动作，则告诉自动化脚本，让他来帮你，或许你的效率会因此得到提高。

在编写自动化测试用例过程中应遵循以下几点原则：
1.一个用例为一个完整的场景，从用户登录系统到最终退出并关闭浏览器。
2.一个用例只验证一个功能点，不要试图在用户登录系统后把所有功能都验证一遍。
3.尽量少的编写逆向逻辑用例。一方面因为逆向逻辑的用例很多（例如手机号输入有十几种情况）；
另一方面自动化脚本本身比较脆弱，对于复杂的逆向逻辑用例实现麻烦且容易出错。
4.用例与用例之间尽量避免产生依赖。
5.一条用例完成测试之后需要对测试场景进行还原，以免影响其他用例的执行。
---数据清理（如果有权限测试环境可以通过接口或SQL清理数据，没有权限也可以不清理；线上环境不要动，风险太大，实在不行可以找开发操作；
   web自动化最基本的清理操作就是关闭浏览器）

补充：
关于第1-2点，复杂的流程可以拆分多个用例，再串起来执行。如果都写在一个用例，步骤太多容易出错。
关于第2-3点，结合1-5，复杂的逆向用例如果影响通过率，则可以拿出来手工测试，并标记好哪些自动化哪些手工。
关于第1-4点，冒烟的目的是能不能用，回归的目的是好不好用。

'''
