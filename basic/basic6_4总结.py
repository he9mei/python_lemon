#!/usr/bin/python3
# -*- coding: utf-8 -*-

# ----老师的笔记---

# 1、为什么封装成类？函数和类有什么区别？？
# 功能包！！  单一的功能 - 10个函数共享，要么就是全局变量要么就是参数传递。
# 功能包！！  有所关联的，共享的部分。私有化

# 面向对象思维

# 2、我知道它的语法它的实现。但是我不知道如何应用更好？
# 应用！！沉浸在类和对象的氛围里。

# 类和对象
# 类是抽象的、对象是实例化的，具体化的。
# 类 = 属性(变量)和行为(函数)
# 调用的时候，多了一个归属。实例对象(self).属性/行为
# 类的内部，归属的是self.  类的外部，是实例对象。

# 实例的属性和行为，类的属性和行为
# 类的属性和行为，所有实例共享。
class A:

    a = 12  # 类的属性

    def __init__(self):  # 初始化函数
        self.cc = "hello,class and object!!"  #  实例属性
        # 准备工作-  一系列逻辑处理。如果说某一个值在其它的函数里面要用，
        # 咱们才设置为self.XXX 。让实例对象的行为能够使用。

    def func_object(self):   # 不是双下划开头和结束的，也不是@classmethod
        # print("1111")        #实例函数
        pass

    @classmethod   # 自动化测试中除了单元测试，比如setupclass用到了classmethod，其他不会用到。
    def class_func(cls):   # 类的行为
        pass

    # 为对外开放的行为  提供内部逻辑处理服务。但这个服务不对外公开。
    def __private_func(self): # 深度私有 - 行为和属性。只有自己的类内部可以访问。子类都不行。
        pass

    def _protected_func(self): # 浅度私有 - 行为和属性。子类的内部也是可以访问的。
        pass




# 私有化、继承、super

# 什么情况下继承？因为你不继承的话，你自己要一个个实现。
# 但是呢，如果有人实现了，你直接把它继承过来，变成你自己的。你就可以偷懒了。
# 子类是不可以更改父类的行为，只能改变你自己，即继承过来的东西，只能用不能改。
# 扩展开放，修改关闭。
class B(A):  # A里面除深度私有外的属性和行为，都是可以通过self.直接访问。

    # 在继承之外，扩展自己的特有的属性和行为。
    def my_func(self):
        pass

    # 在继承的行为当中，在原来的基础上去扩展。行为名称不一样。
    # def my_func2(self,a):
    #     self.func_object()  # 继承的
    #     if a == True:   # 新增的逻辑处理。
    #         print("11111")

    # 在继承的行为当中，重写父类的行为(扩展优化，彻底改革)。行为名称一样。
    # 在子类的同名函数内部，如果要使用父类的同名方法，一定要用super来代替self。
    def func_object(self, a):  # 备注:父类方法没有参数，我重写时新增了参数，不完全一样，是可以的。在Java中称之为多态，Python中没有这个概念。
        # super().func_object()
        if a == 100:
            print("11111")

    def __init__(self,a,b):
        super().__init__()
        print(a)
        print(b)

b = B(2,3)
b.func_object(100)

# 日志操作、配置操作、excel操作、单元测试
# 封装成一个类 - 功能包！！

# 具备面向对象的思维？？ =====
# mongo老师   246  因为周四晚上有上线  接口自动化阶段。
























